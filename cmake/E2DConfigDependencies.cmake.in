# in case of static linking, we must also define the list of all the dependencies of E2D libraries
if(E2D_STATIC_LIBRARIES)
    include(CMakeFindDependencyMacro)

    # detect the OS
    if(${CMAKE_SYSTEM_NAME} MATCHES "Windows")
        set(FIND_E2D_OS_WINDOWS 1)
    elseif(${CMAKE_SYSTEM_NAME} MATCHES "Linux")
        set(FIND_E2D_OS_LINUX 1)
    elseif(${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
        set(FIND_E2D_OS_MACOS 1)
    endif()

    # start with an empty list
    set(FIND_E2D_DEPENDENCIES_NOTFOUND)

    # macro that searches for a 3rd-party library
    function(sfml_bind_dependency)
        cmake_parse_arguments(THIS "" "TARGET;FRIENDLY_NAME" "SEARCH_NAMES" ${ARGN})
        if(THIS_UNPARSED_ARGUMENTS)
            message(FATAL_ERROR "Unknown arguments when calling sfml_bind_dependency: ${THIS_UNPARSED_ARGUMENTS}")
        endif()

        # No lookup in environment variables (PATH on Windows), as they may contain wrong library versions
        find_library(${THIS_FRIENDLY_NAME}_LIB NAMES ${THIS_SEARCH_NAMES}
                     PATHS ${FIND_E2D_PATHS} PATH_SUFFIXES lib NO_SYSTEM_ENVIRONMENT_PATH)
        mark_as_advanced(${THIS_FRIENDLY_NAME}_LIB)
        if(${THIS_FRIENDLY_NAME}_LIB)
            set_property(TARGET ${THIS_TARGET} APPEND PROPERTY INTERFACE_LINK_LIBRARIES "${${THIS_FRIENDLY_NAME}_LIB}")
        else()
            set(FIND_E2D_DEPENDENCIES_NOTFOUND "${FIND_E2D_DEPENDENCIES_NOTFOUND} ${THIS_FRIENDLY_NAME}" PARENT_SCOPE)
        endif()
    endfunction()

    # E2D::Engine
    list(FIND E2D_FIND_COMPONENTS "Engine" FIND_E2D_ENGINE_COMPONENT_INDEX)
    if(FIND_E2D_ENGINE_COMPONENT_INDEX GREATER -1)
        sfml_bind_dependency(TARGET SDL2 FRIENDLY_NAME "SDL2" SEARCH_NAMES "SDL2")
    endif()

    if(FIND_E2D_DEPENDENCIES_NOTFOUND)
        set(FIND_E2D_ERROR "E2D found but some of its dependencies are missing (${FIND_E2D_DEPENDENCIES_NOTFOUND})")
        set(E2D_FOUND FALSE)
    endif()
endif()
